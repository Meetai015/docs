---
title: "State Management"
description: "State management patterns in the Gistly frontend"
icon: "database"
---

# State Management

## Overview

The Gistly frontend uses a **hybrid approach** to state management:

1. **Server State** - React Server Components + API routes
2. **Client State** - React hooks (useState, useContext, useReducer)
3. **Form State** - React Hook Form + Zod validation
4. **URL State** - Next.js search params for filters/pagination

## Server State (Server Components)

### Fetching Data in Server Components

```tsx
// src/app/dashboard/page.tsx
import { fetchMeetings } from '@/lib/api/meetings';

export default async function DashboardPage() {
  const meetings = await fetchMeetings();

  return (
    <div>
      {meetings.map((meeting) => (
        <MeetingCard key={meeting.id} meeting={meeting} />
      ))}
    </div>
  );
}
```

### Revalidation

```tsx
// src/app/actions.ts
'use server';

import { revalidatePath } from 'next/cache';

export async function createMeeting(data: MeetingData) {
  // Create meeting
  await db.meetings.create(data);

  // Revalidate dashboard
  revalidatePath('/dashboard');
}
```

## Client State

### useState for Local State

```tsx
'use client';

import { useState } from 'react';

export function MeetingFilters() {
  const [filters, setFilters] = useState({
    status: 'all',
    dateRange: null,
  });

  return (
    <div>
      <select
        value={filters.status}
        onChange={(e) => setFilters({ ...filters, status: e.target.value })}
      >
        <option value="all">All</option>
        <option value="active">Active</option>
      </select>
    </div>
  );
}
```

### useContext for Global State

```tsx
// src/contexts/auth-context.tsx
'use client';

import { createContext, useContext, useState, ReactNode } from 'react';

interface AuthContextType {
  user: User | null;
  login: (credentials: Credentials) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);

  const login = async (credentials: Credentials) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
    const user = await response.json();
    setUser(user);
  };

  const logout = () => {
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

### useReducer for Complex State

```tsx
// src/reducers/filters-reducer.ts
interface FiltersState {
  status: string;
  dateRange: [Date, Date] | null;
  searchQuery: string;
}

type FiltersAction =
  | { type: 'SET_STATUS'; payload: string }
  | { type: 'SET_DATE_RANGE'; payload: [Date, Date] | null }
  | { type: 'SET_SEARCH_QUERY'; payload: string }
  | { type: 'RESET' };

export function filtersReducer(
  state: FiltersState,
  action: FiltersAction
): FiltersState {
  switch (action.type) {
    case 'SET_STATUS':
      return { ...state, status: action.payload };
    case 'SET_DATE_RANGE':
      return { ...state, dateRange: action.payload };
    case 'SET_SEARCH_QUERY':
      return { ...state, searchQuery: action.payload };
    case 'RESET':
      return { status: 'all', dateRange: null, searchQuery: '' };
    default:
      return state;
  }
}
```

## Form State

### React Hook Form + Zod

```tsx
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';

const meetingSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  date: z.date(),
  attendees: z.array(z.string()).min(1, 'At least one attendee required'),
});

export function MeetingForm() {
  const form = useForm<z.infer<typeof meetingSchema>>({
    resolver: zodResolver(meetingSchema),
    defaultValues: {
      title: '',
      date: new Date(),
      attendees: [],
    },
  });

  const onSubmit = async (data: z.infer<typeof meetingSchema>) => {
    try {
      await createMeeting(data);
      toast.success('Meeting created');
    } catch (error) {
      toast.error('Failed to create meeting');
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Title</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit">Create Meeting</Button>
      </form>
    </Form>
  );
}
```

## URL State

### Using Search Params

```tsx
'use client';

import { useSearchParams, useRouter } from 'next/navigation';

export function MeetingFilters() {
  const searchParams = useSearchParams();
  const router = useRouter();

  const status = searchParams.get('status') || 'all';
  const page = parseInt(searchParams.get('page') || '1');

  const updateFilter = (key: string, value: string) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set(key, value);
    router.push(`?${params.toString()}`);
  };

  return (
    <div>
      <select
        value={status}
        onChange={(e) => updateFilter('status', e.target.value)}
      >
        <option value="all">All</option>
        <option value="active">Active</option>
      </select>
    </div>
  );
}
```

### Server Component with Search Params

```tsx
// src/app/meetings/page.tsx
interface MeetingsPageProps {
  searchParams: { status?: string; page?: string };
}

export default async function MeetingsPage({ searchParams }: MeetingsPageProps) {
  const status = searchParams.status || 'all';
  const page = parseInt(searchParams.page || '1');

  const meetings = await fetchMeetings({ status, page });

  return <MeetingList meetings={meetings} />;
}
```

## API Client

### Fetch Wrapper

```tsx
// src/lib/api/fetch.ts
export async function fetchAPI<T>(
  endpoint: string,
  options?: RequestInit
): Promise<T> {
  const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  });

  if (!response.ok) {
    throw new Error(`API error: ${response.statusText}`);
  }

  return response.json();
}
```

### Typed API Calls

```tsx
// src/lib/api/meetings.ts
import { fetchAPI } from './fetch';

export interface Meeting {
  id: string;
  title: string;
  date: string;
}

export async function fetchMeetings(): Promise<Meeting[]> {
  return fetchAPI<Meeting[]>('/meetings');
}

export async function fetchMeeting(id: string): Promise<Meeting> {
  return fetchAPI<Meeting>(`/meetings/${id}`);
}

export async function createMeeting(data: Partial<Meeting>): Promise<Meeting> {
  return fetchAPI<Meeting>('/meetings', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}
```

## Data Fetching Patterns

### Server Component with Loading

```tsx
// src/app/meetings/page.tsx
import { Suspense } from 'react';

export default function MeetingsPage() {
  return (
    <div>
      <h1>Meetings</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <MeetingList />
      </Suspense>
    </div>
  );
}

async function MeetingList() {
  const meetings = await fetchMeetings();
  return meetings.map((meeting) => <MeetingCard key={meeting.id} meeting={meeting} />);
}
```

### Client-side Fetching with SWR

```tsx
'use client';

import useSWR from 'swr';

export function useMeetings() {
  const { data, error, isLoading } = useSWR('/meetings', fetcher);

  return {
    meetings: data,
    error,
    isLoading,
  };
}

async function fetcher(url: string) {
  const response = await fetch(url);
  return response.json();
}
```

## Best Practices

1. **Use Server Components** when possible - reduces client JS
2. **Minimize client state** - Only use for UI interactions
3. **URL state for filters** - Makes shareable links
4. **Form validation** - Always validate on client and server
5. **Error boundaries** - Handle errors gracefully

## Next Steps

- Set up [API Integration](/frontend/api-integration)
- Configure [Deployment](/frontend/deployment)
